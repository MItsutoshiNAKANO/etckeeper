#!/bin/sh
set -e

### parse options ###
help_flag=
target_dir=
vcs=
conf_file=
conf_dir=
usage_flag=
while getopts "hd:s:f:c:" f
do
	case "$f" in
	h) help_flag=1;;
	d) target_dir="$OPTARG";;
	s) vcs="$OPTARG";;
	f) conf_file="$OPTARG";;
	c) conf_dir="$OPTARG";;
	'?') usage_flag=1 ;;
	esac
done
shift $(($OPTIND - 1))

### usage & help ###
usage() { # output to stdout!
	echo "usage: etckeeper [-h] [-d target_Dir] [-s vcS_type] [-f conf_File] [-c Conf_dir] command [args...]"
}
usage_and_exit() {
	usage # output to stdout!
	exit 1
}
if [ "$usage_flag" = '1' ]; then
	usage_and_exit >&2
fi

### show manual.  ###
show_man () {
	man etckeeper || usage >&2
	exit 0
}
if [ "$help_flag" = "1" ]; then
	show_man
fi

### get command name ###
if [ -z "$1" ]; then
	usage_and_exit >&2
fi
command="$1"
shift 1

### set target dir ###
if [ -n "$target_dir" ]; then
	ETCKEEPER_DIR="$target_dir"
elif [ "x$1" = "x-d" ]; then
	if [ -n "$2" ]; then
		ETCKEEPER_DIR="$2"
		shift 2
	else
		usage_and_exit >&2
	fi
elif [ -z "$ETCKEEPER_DIR" ]; then
	ETCKEEPER_DIR='/etc'
fi
export ETCKEEPER_DIR

### set conf_dif ###
if [ -n "$conf_dir" ]; then
	ETCKEEPER_CONF_DIR="$conf_dir"
fi
if [ -z "$ETCKEEPER_CONF_DIR" ]; then
	ETCKEEPER_CONF_DIR='/etc/etckeeper'
fi
export ETCKEEPER_CONF_DIR

### set conf_file ###
if [ -n "$conf_file" ]; then
	conf="$conf_file"
elif [ "$ETCKEEPER_DIR" != "/etc" ]; then
	conf=''
else
	conf="$ETCKEEPER_CONF_DIR/etckeeper.conf"
fi

### load conf_file ###
if [ -n "$conf" -a -e "$conf" ]; then
	. "$conf"
fi

### cd ###
cd "$ETCKEEPER_DIR"

### set vcs ###
if [ -n "$vcs" ]; then
	VCS="$vcs"
elif [ -n "$VCS" ];then
	true
elif [ -d ".git" ]; then
	VCS=git
elif [ -d ".hg" ]; then
	VCS=hg
elif [ -d "_darcs" ]; then
	VCS=darcs
elif [ -d ".bzr" ]; then
	VCS=bzr
else
	echo "Please configure a VCS in $conf" >&2
	exit 1
fi
case "$VCS" in
git) ;;
hg) ;;
darcs) ;;
bzr) ;;
*)
	echo "etckeeper: does not support $VCS." >&2
	exit 1;;
esac
export VCS

### reset variables ###
if [ -n "$GIT_WORK_TREE" ]; then
	unset GIT_WORK_TREE
fi
if [ -n "$GIT_DIR" ]; then
	unset GIT_DIR
fi

if [ ! -z "$GIT_COMMIT_OPTIONS" ]; then
	export GIT_COMMIT_OPTIONS
fi
if [ ! -z "$HG_COMMIT_OPTIONS" ]; then
	export HG_COMMIT_OPTIONS
fi
if [ ! -z "$BZR_COMMIT_OPTIONS" ]; then
	export BZR_COMMIT_OPTIONS
fi
if [ ! -z "$DARCS_COMMIT_OPTIONS" ]; then
	export DARCS_COMMIT_OPTIONS
fi

if [ ! -z "$HIGHLEVEL_PACKAGE_MANAGER" ]; then
	export HIGHLEVEL_PACKAGE_MANAGER
fi
if [ ! -z "$LOWLEVEL_PACKAGE_MANAGER" ]; then
	export LOWLEVEL_PACKAGE_MANAGER
fi
if [ ! -z "$AVOID_COMMIT_BEFORE_INSTALL" ]; then
	export AVOID_COMMIT_BEFORE_INSTALL
fi
if [ ! -z "$AVOID_SPECIAL_FILE_WARNING" ]; then
	export AVOID_SPECIAL_FILE_WARNING
fi
if [ ! -z "$PUSH_REMOTE" ]; then
	export PUSH_REMOTE
fi

### set PATH ###
program_directory="${0%/*}"
if [ -n "$program_directory" ]; then
	PATH="$PATH:$program_directory"
	export PATH
fi

### do ###
# compatability code
if [ "$command" = "post-apt" ]; then
	command=post-install
elif [ "$command" = "pre-apt" ]; then
	command=pre-install
fi

if echo "$command" | egrep -q '[^-a-z_]'; then
	echo "etckeeper: invalid command $command" >&2
	exit 1
fi

if [ ! -d "$ETCKEEPER_CONF_DIR/$command.d" ]; then
	echo "etckeeper: $ETCKEEPER_CONF_DIR/$command.d does not exist" >&2
	exit 1
fi

lsscripts() {
	perl -e '
		$dir=shift;
		print join "\n", grep { ! -d $_ && -x $_ }
			grep /^\Q$dir\/\E[-a-zA-Z0-9]+$/,
			glob "$dir/*";
	' "$1"
}

for script in $(lsscripts "$ETCKEEPER_CONF_DIR/$command.d"); do
	"$script" "$@"
done
